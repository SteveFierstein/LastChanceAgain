<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FinsAndPins Board Selector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui; background: #111; color: #f5f5f5; padding: 1rem; }
    h1 { font-size: 1.4rem; margin-bottom: 0.5rem; }
    .controls { display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap; }
    button { background: #2d8cff; color: #fff; border: none; padding: 0.4rem 0.8rem; border-radius: 4px; font-size: 0.9rem; }
    button:disabled { background: #555; }
    .boards-container { display: flex; flex-direction: column; gap: 1rem; }
    .board { background: #181818; border-radius: 6px; padding: 0.5rem; border: 1px solid #333; }
    .board-header, .board-footer { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 0.3rem; }
    canvas { width: 100%; height: auto; border-radius: 4px; background: #000; touch-action: manipulation; }
    .status { font-size: 0.8rem; color: #ccc; }
  </style>
</head>
<body>
  <h1>FinsAndPins Board Selector</h1>
  <div class="controls">
    <button id="downloadAllBtn" disabled>Download All Boards</button>
    <span id="globalStatus" class="status"></span>
  </div>
  <div class="boards-container" id="boardsContainer"></div>

  <script>
    const BOX_STROKE_COLOR = "rgba(255,255,0,0.95)";
    const BOX_FILL_COLOR = "rgba(255,255,0,0.15)";
    const BOX_LINE_WIDTH = 6;

    const boardsContainer = document.getElementById("boardsContainer");
    const globalStatus = document.getElementById("globalStatus");
    const downloadAllBtn = document.getElementById("downloadAllBtn");

    const boards = [];
    let observer = null;

    document.addEventListener("DOMContentLoaded", init);

    async function init() {
      globalStatus.textContent = "Loading board list...";

      const boardFiles = await fetchBoardList();
      if (boardFiles.length === 0) {
        globalStatus.textContent = "No boards found in /boards/";
        return;
      }

      boardFiles.forEach(base => boards.push(createBoard(base)));

      setupLazyLoading();
      globalStatus.textContent = `Ready: ${boards.length} boards`;
      downloadAllBtn.disabled = false;
    }

    async function fetchBoardList() {
      try {
        const res = await fetch("./boards/");
        const text = await res.text();
        const matches = [...text.matchAll(/href="([^"]+\.(jpg|jpeg|png))"/gi)];
        return matches.map(m => m[1].replace(/\.(jpg|jpeg|png)$/i, ""));
      } catch (err) {
        console.error("Error listing boards:", err);
        return [];
      }
    }

    function createBoard(baseName) {
      const div = document.createElement("div");
      div.className = "board";

      const header = document.createElement("div");
      header.className = "board-header";

      const title = document.createElement("span");
      title.textContent = baseName;

      const downloadBtn = document.createElement("button");
      downloadBtn.textContent = "Download";
      downloadBtn.disabled = true;

      header.append(title, downloadBtn);

      const canvas = document.createElement("canvas");

      const footer = document.createElement("div");
      footer.className = "board-footer";

      const status = document.createElement("span");
      status.className = "status";
      status.textContent = "Waiting to load...";

      const count = document.createElement("span");

      footer.append(status, count);

      div.append(header, canvas, footer);
      boardsContainer.appendChild(div);

      const board = {
        baseName,
        element: div,
        canvas,
        statusEl: status,
        countEl: count,
        downloadBtn,
        loaded: false,
        boxes: null,
        img: null
      };

      downloadBtn.onclick = () => {
        if (!board.loaded) return alert("Scroll the board into view first.");
        const url = board.canvas.toDataURL("image/png");
        triggerDownload(url, `${baseName}_circled.png`);
      };

      return board;
    }

    function setupLazyLoading() {
      observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          const board = boards.find(b => b.element === entry.target);
          if (entry.isIntersecting) {
            if (!board.loaded) loadBoard(board);
          } else {
            unloadBoard(board);
          }
        });
      }, { rootMargin: "200px 0px", threshold: 0.01 });

      boards.forEach(b => observer.observe(b.element));
    }

    async function loadBoard(board) {
      const { baseName, canvas, statusEl, countEl, downloadBtn } = board;
      board.loaded = true;
      statusEl.textContent = "Loading...";

      try {
        const img = await loadImage(`./boards/${baseName}.jpg`);
        board.img = img;

        const json = await fetch(`./boards/${baseName}.json`).then(r => r.json());
        const boxes = normalizeBoxes(json.predictions || json.boxes || json.output?.predictions || json || []);
        board.boxes = boxes;

        const ctx = canvas.getContext("2d");
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;

        ctx.drawImage(img, 0, 0);

        statusEl.textContent = boxes.length ? `${boxes.length} pins` : "No boxes found";

        const key = `finsandpins-${baseName}`;
        let selected = JSON.parse(localStorage.getItem(key) || "[]");

        redraw(ctx, img, boxes, selected);
        countEl.textContent = selected.length ? `${selected.length} selected` : "";

        canvas.onclick = evt => {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const x = (evt.clientX - rect.left) * scaleX;
          const y = (evt.clientY - rect.top) * scaleY;

          const hit = boxes.findIndex(b => x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height);
          if (hit === -1) return;

          const idx = selected.indexOf(hit);
          if (idx === -1) selected.push(hit);
          else selected.splice(idx, 1);

          localStorage.setItem(key, JSON.stringify(selected));

          redraw(ctx, img, boxes, selected);
          countEl.textContent = selected.length ? `${selected.length} selected` : "";
        };

        downloadBtn.disabled = false;

      } catch (err) {
        console.error("Error loading board", baseName, err);
        statusEl.textContent = "Error loading board";
      }
    }

    function unloadBoard(board) {
      if (!board.loaded) return;
      board.loaded = false;
      board.img = null;
      board.boxes = null;

      const ctx = board.canvas.getContext("2d");
      ctx.clearRect(0, 0, board.canvas.width, board.canvas.height);

      board.statusEl.textContent = "Unloaded";
      board.countEl.textContent = "";
      board.downloadBtn.disabled = true;
    }

    function normalizeBoxes(arr) {
      return arr.map(b => ({
        x: b.x - b.width / 2,
        y: b.y - b.height / 2,
        width: b.width,
        height: b.height
      }));
    }

    function redraw(ctx, img, boxes, selected) {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.drawImage(img, 0, 0);

      ctx.lineWidth = BOX_LINE_WIDTH;
      ctx.strokeStyle = BOX_STROKE_COLOR;
      ctx.fillStyle = BOX_FILL_COLOR;

      selected.forEach(i => {
        const b = boxes[i];
        ctx.beginPath();
        ctx.rect(b.x, b.y, b.width, b.height);
        ctx.fill();
        ctx.stroke();
      });
    }

    function loadImage(url) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.onload = () => res(img);
        img.onerror = rej;
        img.src = url;
      });
    }

    function triggerDownload(url, filename) {
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
    }
  </script>
</body>
</html>
